# Python & FastAPI, Celery & RabbitMQ, Kubernetes (K8s)

1. 사용자 요청이 FastAPI 어플리케이션으로 들어옵니다.
2. 필요한 비동기 작업이 있다면, FastAPI 어플리케이션은 해당 작업을 Celery로 스케쥴링하고, 사용자에게 즉시 응답을 반환합니다.
3. Celery는 RabbitMQ를 통해 이 작업을 분산된 작업자에게 전달합니다.
4. Celery 작업자는 받은 작업을 처리하고, 결과를 필요한 곳에 저장합니다.
5. FastAPI 어플리케이션, Celery, RabbitMQ는 각각 독립된 컨테이너로 패키징되어 Kubernetes에서 관리되고, 스케일링 됩니다.
6. 이러한 구성은 요청의 처리를 비동기적으로 분산시켜 속도를 높이고, Kubernetes를 통한 자동 스케일링으로 트래픽 변동에 유연하게 대응할 수 있도록 합니다. 그러나 실제 배포 환경에서는 보안, 로깅, 모니터링, 에러 핸들링 등의 다른 요소도 고려해야 할 것입니다.



## Celery 사용하는 이유
- fastAPI 가 비동기 요청을 처리 할 수 있지만, 긴 처리 시간이 필요한 작업의 경우 사용자에게 즉시 응답을 반환하고 작업을 백그라운드에서 진행하는것이 좋다.
- 예를들어 이미지 렌더링이나 데이터 처리 같은 무거운 작업을 서버가 직접 처리하게 되면 요청을 처리하는 동안 서버가 블로킹 되어 다른 요청을 받지 못하게 될 수 있다.
- Celery 는 분산된 여러 작업자로 분배할 수 있다. 모든 작업이 동일한 서버에서 실행될 필요가 없음을 의미.
- 작업을 처리하는 도중 서버에 문제가 발생하면 그 작업은 실패 할 수 있다.
- 하지만 celery 를 사용하면 작업이 중단된 지점에서 다시 시작하거나 다른 작업자가 그 작업을 가져와 처리할수 있다.
- Celery 는 주기적으로 반복해야하는 작업에 대해서도 지원

# FastAPI 비동기 vs Celery 비동기
- FastAPI 의 비동기 처리 기능은 웹 요청에 대한 응답을 빠르게 반환하고, 동시에 여러 요청을 처리하는데 유리하지만
- 긴 시간이 필요한 작업, 분산 처리가 필요한 작업, 장애 허용이 필요한 작업, 혹은 정기적으로 실행해야하는 작업 등은 Celery 와 같은 비동기 작업 큐를 사용하는것이 더 효과적일수 있다.
