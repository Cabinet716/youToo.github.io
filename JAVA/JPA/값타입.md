## 값 타입 

### 기본값 타임 : 
- 자바 기본 타입 : int, double
  - ex) 회원을 삭제하면 이름, 나이 필드도 함께 삭제
  - 값을 복사하기 때문에 공유가 안됨.
- 래퍼 클래스 : Integer, Long
- String 
  - 공유 가능한 객체이지만 변경 x 


### 임베디드 타입
```java
@Embeddable
public class Address {
  private String city;
  private String street;
  private String zipcode;
  
  // 기본 생성자 필수
}
```
```java
@Embedded
private Address homeAddress; // 값이 null 인 경우 class 안에 있는 멤버변수도 모두 null

@Embedded
@AttributeOverrides({
@AttributeOverride(name="city", column=@Column(name = "work_city")),
@AttributeOverride(name="street", column=@Column(name = "work_street")),
@AttributeOverride(name="zipcode", column=@Column(name = "work_zipcode")),
})
private Address workAddress;
```


### embeded type 값 타입과 불변 객체
- 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 
- 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.
- 자바 기본 타입에 값을 대입하면 값을 복사한다. 그러나 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다. 


```java
Address Address = new Address("city","street","123456");

Member member = new Member();
member.setUserName("member1");
member.setHomeAddress(Address);
em.persist(member1);

Member member2 = new Member();
member2.setUserName("member1");
membe2r.setHomeAddress(Address);
em.persist(member2);

member.getHomeAddress().setCity("newCity") // member1, member2 의 city 둘다 바뀜 !!! 주의!!!
```
```java
Address address = new Address("city","street","123456");

Member member = new Member();
member.setUserName("member1");
member.setHomeAddress(address);
em.persist(member1);

Address address2 = new Address(address.getCity(), address.getStreet(), address.getCity()); // 복사해서 사용 해야함

Member member2 = new Member();
member2.setUserName("member1");
membe2r.setHomeAddress(address2);
em.persist(member2);

member.getHomeAddress().setCity("newCity") // member1 city 만 바뀜.
```
- 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단 : 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨
- 값 타입은 불변 객체(immutable object)로 설계해야함 - 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
